var relearn_search_index = [
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates",
    "content": " No Title Link 1 Graphs Click to view ",
    "description": "",
    "tags": null,
    "title": "Algorithms",
    "uri": "/competitive-programming/templates/algorithms/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms \u003e Graphs",
    "content": "\r​\rPython\rJava\rC++\rdef bellman_ford(edges, num_vertices, source): distance = [float('inf')] * num_vertices distance[source] = 0 # Relax all edges |V| - 1 times for _ in range(num_vertices - 1): for u, v, weight in edges: if distance[u] != float('inf') and distance[u] + weight \u003c distance[v]: distance[v] = distance[u] + weight # Check for negative-weight cycles for u, v, weight in edges: if distance[u] != float('inf') and distance[u] + weight \u003c distance[v]: print(\"Graph contains negative weight cycle!\") return [] return distance edges = [(0, 1, 4), (0, 2, 3), (1, 2, -1), (1, 3, 2), (1, 4, 3), (3, 2, 5), (3, 1, 1), (4, 3, -3)] num_vertices = 5 source = 0 shortest_distances = bellman_ford(edges, num_vertices, source) if shortest_distances: print(\"Shortest distances from vertex\", source) for i in range(num_vertices): print(\"Vertex\", i, \":\", shortest_distances[i])\rimport java.util.*; public class BellmanFordHelper { static class Edge { int source, destination, weight; public Edge(int source, int destination, int weight) { this.source = source; this.destination = destination; this.weight = weight; } } public static int[] bellmanFord(List\u003cEdge\u003e edges, int numVertices, int source) { int[] distance = new int[numVertices]; Arrays.fill(distance, Integer.MAX_VALUE); distance[source] = 0; // Relax all edges |V| - 1 times for (int i = 0; i \u003c numVertices - 1; i++) { for (Edge edge : edges) { int u = edge.source; int v = edge.destination; int weight = edge.weight; if (distance[u] != Integer.MAX_VALUE \u0026\u0026 distance[u] + weight \u003c distance[v]) { distance[v] = distance[u] + weight; } } } // Check for negative-weight cycles for (Edge edge : edges) { int u = edge.source; int v = edge.destination; int weight = edge.weight; if (distance[u] != Integer.MAX_VALUE \u0026\u0026 distance[u] + weight \u003c distance[v]) { System.out.println(\"Graph contains negative weight cycle!\"); return new int[0]; // Return empty array to indicate negative cycle } } return distance; } public static void main(String[] args) { List\u003cEdge\u003e edges = Arrays.asList(new Edge(0, 1, 4), new Edge(0, 2, 3), new Edge(1, 2, -1), new Edge(1, 3, 2), new Edge(1, 4, 3), new Edge(3, 2, 5), new Edge(3, 1, 1), new Edge(4, 3, -3)); int numVertices = 5; int source = 0; int[] shortestDistances = bellmanFord(edges, numVertices, source); if (shortestDistances.length \u003e 0) { System.out.println(\"Shortest distances from vertex \" + source + \":\"); for (int i = 0; i \u003c numVertices; ++i) { System.out.println(\"Vertex \" + i + \": \" + shortestDistances[i]); } } } }\r#include \u003ciostream\u003e #include \u003cvector\u003e #include \u003climits\u003e using namespace std; struct Edge { int source, destination, weight; }; vector\u003cint\u003e bellmanFord(vector\u003cEdge\u003e\u0026 edges, int numVertices, int source) { vector\u003cint\u003e distance(numVertices, INT_MAX); distance[source] = 0; // Relax all edges |V| - 1 times for (int i = 0; i \u003c numVertices - 1; i++) { for (const auto\u0026 edge : edges) { int u = edge.source; int v = edge.destination; int weight = edge.weight; if (distance[u] != INT_MAX \u0026\u0026 distance[u] + weight \u003c distance[v]) { distance[v] = distance[u] + weight; } } } // Check for negative-weight cycles for (const auto\u0026 edge : edges) { int u = edge.source; int v = edge.destination; int weight = edge.weight; if (distance[u] != INT_MAX \u0026\u0026 distance[u] + weight \u003c distance[v]) { cout \u003c\u003c \"Graph contains negative weight cycle!\" \u003c\u003c endl; return vector\u003cint\u003e(); // Return empty vector to indicate negative cycle } } return distance; } int main() { vector\u003cEdge\u003e edges = {{0, 1, 4}, {0, 2, 3}, {1, 2, -1}, {1, 3, 2}, {1, 4, 3}, {3, 2, 5}, {3, 1, 1}, {4, 3, -3}}; int numVertices = 5; int source = 0; vector\u003cint\u003e shortestDistances = bellmanFord(edges, numVertices, source); if (!shortestDistances.empty()) { cout \u003c\u003c \"Shortest distances from vertex \" \u003c\u003c source \u003c\u003c \":\" \u003c\u003c endl; for (int i = 0; i \u003c numVertices; ++i) { cout \u003c\u003c \"Vertex \" \u003c\u003c i \u003c\u003c \": \" \u003c\u003c shortestDistances[i] \u003c\u003c endl; } } return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Bellman-ford",
    "uri": "/competitive-programming/templates/algorithms/graphs/bellmanford/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan",
    "content": " No Title Link 1 Templates Click to view 2 Tricks Click to view 3 Ideas Click to view ",
    "description": "",
    "tags": null,
    "title": "Competitive Programming",
    "uri": "/competitive-programming/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates",
    "content": " No Title Link 1 Trie Click to view 2 Segment Tree Click to view 3 Fenwick Tree Click to view ",
    "description": "",
    "tags": null,
    "title": "Data Structures",
    "uri": "/competitive-programming/templates/datastructures/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms \u003e Graphs",
    "content": "\r​\rPython\rJava\rC++\rimport heapq def dijkstra(graph, start): num_vertices = len(graph) distances = [float('inf')] * num_vertices distances[start] = 0 pq = [(0, start)] while pq: dist_u, u = heapq.heappop(pq) if dist_u \u003e distances[u]: continue for v, weight in graph[u]: if distances[v] \u003e dist_u + weight: distances[v] = dist_u + weight heapq.heappush(pq, (distances[v], v)) return distances if __name__ == \"__main__\": num_vertices = 6 graph = [[] for _ in range(num_vertices)] # Example graph represented as an adjacency list graph[0].extend([(1, 5), (2, 3)]) graph[1].extend([(0, 5), (2, 2), (3, 1)]) graph[2].extend([(0, 3), (1, 2), (3, 4), (4, 2)]) graph[3].extend([(1, 1), (2, 4), (4, 1), (5, 4)]) graph[4].extend([(2, 2), (3, 1), (5, 3)]) graph[5].extend([(3, 4), (4, 3)]) start_vertex = 0 print(\"Shortest distances from vertex\", start_vertex) print(dijkstra(graph, start_vertex))\rimport java.util.*; public class DijkstraAlgorithm { static class Pair\u003cU, V\u003e { public final U first; public final V second; public Pair(U first, V second) { this.first = first; this.second = second; } } public static void dijkstra(ArrayList\u003cArrayList\u003cPair\u003cInteger, Integer\u003e\u003e\u003e graph, int start, int numVertices, int[] distances) { PriorityQueue\u003cPair\u003cInteger, Integer\u003e\u003e pq = new PriorityQueue\u003c\u003e(Comparator.comparingInt(pair -\u003e pair.second)); distances[start] = 0; pq.offer(new Pair\u003c\u003e(start, 0)); while (!pq.isEmpty()) { int u = pq.poll().first; for (Pair\u003cInteger, Integer\u003e neighbor : graph.get(u)) { int v = neighbor.first; int weight = neighbor.second; if (distances[v] \u003e distances[u] + weight) { distances[v] = distances[u] + weight; pq.offer(new Pair\u003c\u003e(v, distances[v])); } } } } public static void main(String[] args) { int numVertices = 6; ArrayList\u003cArrayList\u003cPair\u003cInteger, Integer\u003e\u003e\u003e graph = new ArrayList\u003c\u003e(numVertices); for (int i = 0; i \u003c numVertices; i++) { graph.add(new ArrayList\u003c\u003e()); } // Example graph represented as an adjacency list graph.get(0).add(new Pair\u003c\u003e(1, 5)); graph.get(0).add(new Pair\u003c\u003e(2, 3)); graph.get(1).add(new Pair\u003c\u003e(0, 5)); graph.get(1).add(new Pair\u003c\u003e(2, 2)); graph.get(1).add(new Pair\u003c\u003e(3, 1)); graph.get(2).add(new Pair\u003c\u003e(0, 3)); graph.get(2).add(new Pair\u003c\u003e(1, 2)); graph.get(2).add(new Pair\u003c\u003e(3, 4)); graph.get(2).add(new Pair\u003c\u003e(4, 2)); graph.get(3).add(new Pair\u003c\u003e(1, 1)); graph.get(3).add(new Pair\u003c\u003e(2, 4)); graph.get(3).add(new Pair\u003c\u003e(4, 1)); graph.get(3).add(new Pair\u003c\u003e(5, 4)); graph.get(4).add(new Pair\u003c\u003e(2, 2)); graph.get(4).add(new Pair\u003c\u003e(3, 1)); graph.get(4).add(new Pair\u003c\u003e(5, 3)); graph.get(5).add(new Pair\u003c\u003e(3, 4)); graph.get(5).add(new Pair\u003c\u003e(4, 3)); int[] distances = new int[numVertices]; Arrays.fill(distances, Integer.MAX_VALUE); int startVertex = 0; System.out.println(\"Shortest distances from vertex \" + startVertex); dijkstra(graph, startVertex, numVertices, distances); for (int i = 0; i \u003c numVertices; i++) { System.out.println(\"Vertex \" + i + \": \" + distances[i]); } } }\r#include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cqueue\u003e #include \u003climits\u003e using namespace std; void dijkstra(vector\u003cpair\u003cint, int\u003e\u003e adj[], int num_vertices, int start, vector\u003cint\u003e\u0026 distances) { priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, greater\u003cpair\u003cint, int\u003e\u003e\u003e pq; // Min-heap to store (distance, vertex) pairs distances[start] = 0; pq.push({0, start}); while (!pq.empty()) { int u = pq.top().second; int dist_u = pq.top().first; pq.pop(); // Check all neighbors of vertex u for (const auto\u0026 neighbor : adj[u]) { int v = neighbor.first; int weight = neighbor.second; // Relaxation step if (distances[v] \u003e dist_u + weight) { distances[v] = dist_u + weight; pq.push({distances[v], v}); } } } } int main() { int num_vertices = 6; vector\u003cpair\u003cint, int\u003e\u003e adj[num_vertices]; // Example graph represented as an adjacency list adj[0].push_back({1, 5}); adj[0].push_back({2, 3}); adj[1].push_back({0, 5}); adj[1].push_back({2, 2}); adj[1].push_back({3, 1}); adj[2].push_back({0, 3}); adj[2].push_back({1, 2}); adj[2].push_back({3, 4}); adj[2].push_back({4, 2}); adj[3].push_back({1, 1}); adj[3].push_back({2, 4}); adj[3].push_back({4, 1}); adj[3].push_back({5, 4}); adj[4].push_back({2, 2}); adj[4].push_back({3, 1}); adj[4].push_back({5, 3}); adj[5].push_back({3, 4}); adj[5].push_back({4, 3}); vector\u003cint\u003e distances(num_vertices, numeric_limits\u003cint\u003e::max()); int start_vertex = 0; cout \u003c\u003c \"Shortest distances from vertex \" \u003c\u003c start_vertex \u003c\u003c endl; dijkstra(adj, num_vertices, start_vertex, distances); for (int i = 0; i \u003c num_vertices; ++i) { cout \u003c\u003c \"Vertex \" \u003c\u003c i \u003c\u003c \": \" \u003c\u003c distances[i] \u003c\u003c endl; } return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Dijkstra",
    "uri": "/competitive-programming/templates/algorithms/graphs/dijkstra/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Data Structures",
    "content": " No Title Link 1 Range Sum Click to view ",
    "description": "",
    "tags": null,
    "title": "Fenwick Tree",
    "uri": "/competitive-programming/templates/datastructures/fenwicktree/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms \u003e Graphs",
    "content": "\r​\rPython\rJava\rC++\rdef floyd_warshall_helper(graph): num_vertices = len(graph) # Initialize distances matrix with given graph distances = [row[:] for row in graph] # Apply Floyd-Warshall algorithm for k in range(num_vertices): for i in range(num_vertices): for j in range(num_vertices): if distances[i][k] != float('inf') and distances[k][j] != float('inf'): distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j]) return distances # Example graph represented as an adjacency matrix graph = [[0, 5, float('inf'), 10], [float('inf'), 0, 3, float('inf')], [float('inf'), float('inf'), 0, 1], [float('inf'), float('inf'), float('inf'), 0]] shortest_distances = floyd_warshall_helper(graph) # Use shortest_distances in other methods...\rimport java.util.Arrays; public class FloydWarshallHelper { public static int[][] floydWarshallHelper(int[][] graph) { int numVertices = graph.length; // Initialize distances matrix with given graph int[][] distances = new int[numVertices][numVertices]; for (int i = 0; i \u003c numVertices; ++i) { System.arraycopy(graph[i], 0, distances[i], 0, numVertices); } // Apply Floyd-Warshall algorithm for (int k = 0; k \u003c numVertices; ++k) { for (int i = 0; i \u003c numVertices; ++i) { for (int j = 0; j \u003c numVertices; ++j) { if (distances[i][k] != Integer.MAX_VALUE \u0026\u0026 distances[k][j] != Integer.MAX_VALUE \u0026\u0026 distances[i][k] + distances[k][j] \u003c distances[i][j]) { distances[i][j] = distances[i][k] + distances[k][j]; } } } } return distances; } public static void main(String[] args) { int numVertices = 4; // Example graph represented as an adjacency matrix int[][] graph = {{0, 5, Integer.MAX_VALUE, 10}, {Integer.MAX_VALUE, 0, 3, Integer.MAX_VALUE}, {Integer.MAX_VALUE, Integer.MAX_VALUE, 0, 1}, {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, 0}}; int[][] shortestDistances = floydWarshallHelper(graph); // Use shortestDistances in other methods... } }\r#include \u003ciostream\u003e #include \u003cvector\u003e #include \u003climits\u003e using namespace std; vector\u003cvector\u003cint\u003e\u003e floydWarshallHelper(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) { int numVertices = graph.size(); // Initialize distances matrix with given graph vector\u003cvector\u003cint\u003e\u003e distances = graph; // Apply Floyd-Warshall algorithm for (int k = 0; k \u003c numVertices; ++k) { for (int i = 0; i \u003c numVertices; ++i) { for (int j = 0; j \u003c numVertices; ++j) { if (distances[i][k] != INT_MAX \u0026\u0026 distances[k][j] != INT_MAX \u0026\u0026 distances[i][k] + distances[k][j] \u003c distances[i][j]) { distances[i][j] = distances[i][k] + distances[k][j]; } } } } return distances; } int main() { int numVertices = 4; // Example graph represented as an adjacency matrix vector\u003cvector\u003cint\u003e\u003e graph = {{0, 5, INT_MAX, 10}, {INT_MAX, 0, 3, INT_MAX}, {INT_MAX, INT_MAX, 0, 1}, {INT_MAX, INT_MAX, INT_MAX, 0}}; vector\u003cvector\u003cint\u003e\u003e shortestDistances = floydWarshallHelper(graph); // Use shortestDistances in other methods... return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Floyd-Warshall",
    "uri": "/competitive-programming/templates/algorithms/graphs/floydwarshall/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms",
    "content": " No Title Link 1 Union-Find Click to view 2 Dijkstra Click to view 3 Bellman-Ford Click to view 4 Floyd-Warshall Click to view ",
    "description": "",
    "tags": null,
    "title": "Graphs",
    "uri": "/competitive-programming/templates/algorithms/graphs/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Ideas",
    "uri": "/competitive-programming/ideas/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms \u003e Strings",
    "content": "\r​\rPython\rJava\rC++\rdef compute_prefix(pattern): m = len(pattern) pi = [0] * m j = 0 for i in range(1, m): while j \u003e 0 and pattern[i] != pattern[j]: j = pi[j - 1] if pattern[i] == pattern[j]: j += 1 pi[i] = j return pi def KMP(text, pattern): n, m = len(text), len(pattern) pi = compute_prefix(pattern) j = 0 for i in range(n): while j \u003e 0 and text[i] != pattern[j]: j = pi[j - 1] if text[i] == pattern[j]: j += 1 if j == m: print(\"Pattern found at index\", i - j + 1) j = pi[j - 1] text = \"ABABDABACDABABCABAB\" pattern = \"ABABCABAB\" KMP(text, pattern)\rimport java.util.*; public class KMP { public static int[] computePrefix(String pattern) { int m = pattern.length(); int[] pi = new int[m]; for (int i = 1, j = 0; i \u003c m; ++i) { while (j \u003e 0 \u0026\u0026 pattern.charAt(i) != pattern.charAt(j)) j = pi[j - 1]; if (pattern.charAt(i) == pattern.charAt(j)) j++; pi[i] = j; } return pi; } public static void KMP(String text, String pattern) { int n = text.length(), m = pattern.length(); int[] pi = computePrefix(pattern); int j = 0; for (int i = 0; i \u003c n; ++i) { while (j \u003e 0 \u0026\u0026 text.charAt(i) != pattern.charAt(j)) j = pi[j - 1]; if (text.charAt(i) == pattern.charAt(j)) j++; if (j == m) { System.out.println(\"Pattern found at index \" + (i - j + 1)); j = pi[j - 1]; } } } public static void main(String[] args) { String text = \"ABABDABACDABABCABAB\"; String pattern = \"ABABCABAB\"; KMP(text, pattern); } }\r#include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e using namespace std; vector\u003cint\u003e computePrefix(const string\u0026 pattern) { int m = pattern.size(); vector\u003cint\u003e pi(m); for (int i = 1, j = 0; i \u003c m; ++i) { while (j \u003e 0 \u0026\u0026 pattern[i] != pattern[j]) j = pi[j - 1]; if (pattern[i] == pattern[j]) j++; pi[i] = j; } return pi; } void KMP(const string\u0026 text, const string\u0026 pattern) { int n = text.size(), m = pattern.size(); vector\u003cint\u003e pi = computePrefix(pattern); for (int i = 0, j = 0; i \u003c n; ++i) { while (j \u003e 0 \u0026\u0026 text[i] != pattern[j]) j = pi[j - 1]; if (text[i] == pattern[j]) j++; if (j == m) { cout \u003c\u003c \"Pattern found at index \" \u003c\u003c i - j + 1 \u003c\u003c endl; j = pi[j - 1]; } } } int main() { string text = \"ABABDABACDABABCABAB\"; string pattern = \"ABABCABAB\"; KMP(text, pattern); return 0; }\r",
    "description": "",
    "tags": null,
    "title": "KMP",
    "uri": "/competitive-programming/templates/algorithms/strings/kmp/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Are you passionate about programming, data structures, algorithms, and competitive coding? Look no further! Kode Kaavalan is your go-to destination for all things related to mastering programming challenges and honing your problem-solving skills.\nWhat Sets Us Apart Algorithmic Insights: Explore in-depth explanations and intuitive breakdowns of algorithmic concepts ranging from classic sorting and searching techniques to dynamic programming, graph algorithms, and beyond. Our blog is your gateway to understanding the intricate logic behind these algorithms, empowering you to tackle complex coding challenges with confidence.\nProgramming Contest Problems: Immerse yourself in a treasure trove of programming contest problems curated from leading platforms such as Codeforces, Codechef, LeetCode, and AtCoder. Each problem comes with a detailed analysis, providing valuable insights into problem-solving strategies and algorithmic approaches.\nComprehensive Tutorials: Whether you’re a beginner or an experienced coder, our comprehensive tutorials cater to all skill levels. From foundational concepts to advanced techniques, we cover everything you need to know to excel in competitive programming and beyond.\nInteractive Learning Experience: Engage with our content through interactive code examples, visualizations, and real-world applications. We believe in learning by doing, and our hands-on approach ensures that you not only understand algorithms and data structures but also how to apply them effectively in practice.\nThriving Community: Join our vibrant community of programming enthusiasts, where you can connect with like-minded individuals, share insights, and collaborate on solving challenging problems. Whether you’re seeking advice, discussing solutions, or simply celebrating your coding victories, you’ll find a supportive network ready to cheer you on.\nEmbark on Your Coding Journey Today!\nReady to embark on an exciting journey through the realms of algorithms, data structures, and competitive coding? Dive into our latest posts, tutorials, and problem-solving guides to elevate your programming skills to new heights. Whether you’re aiming for success in coding interviews, competitions, or personal projects, [Your Blog Name] is your trusted companion every step of the way.\nLet’s unravel the mysteries of algorithms, one problem at a time. Welcome to a world of endless possibilities, where curiosity meets creativity, and challenges become opportunities for growth. Join us on [Your Blog Name] and start coding your way to success!\n",
    "description": "",
    "tags": null,
    "title": "Kode Kaavalan",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Data Structures \u003e Segment Tree",
    "content": "\r​\rPython\rJava\rC++\rclass Node: def __init__(self, max1=-1, cnt1=0, max2=-1, cnt2=0): self.max1 = max1 self.cnt1 = cnt1 self.max2 = max2 self.cnt2 = cnt2 class SegmentTree: def __init__(self, arr): self.arr = arr self.n = len(arr) self.t = [Node() for _ in range(4 * self.n)] self.build(1, 0, self.n - 1) def merge(self, left, right): vals = [ (left.max1, left.cnt1), (right.max1, right.cnt1), (left.max2, left.cnt2), (right.max2, right.cnt2) ] vals.sort(reverse=True) parent = Node(vals[0][0], vals[0][1]) for val, cnt in vals[1:]: if val == parent.max1: parent.cnt1 += cnt elif parent.max2 \u003c val \u003c parent.max1: parent.max2 = val parent.cnt2 = cnt elif val == parent.max2: parent.cnt2 += cnt return parent def build(self, v, tl, tr): if tl == tr: self.t[v] = Node(self.arr[tl], 1) else: tm = (tl + tr) // 2 self.build(v * 2, tl, tm) self.build(v * 2 + 1, tm + 1, tr) self.t[v] = self.merge(self.t[v * 2], self.t[v * 2 + 1]) def update(self, v, tl, tr, pos, new_val): if tl == tr: self.t[v] = Node(new_val, 1) else: tm = (tl + tr) // 2 if pos \u003c= tm: self.update(v * 2, tl, tm, pos, new_val) else: self.update(v * 2 + 1, tm + 1, tr, pos, new_val) self.t[v] = self.merge(self.t[v * 2], self.t[v * 2 + 1]) def query(self, v, tl, tr, l, r): if l \u003e r: return Node() if l == tl and r == tr: return self.t[v] tm = (tl + tr) // 2 return self.merge(self.query(v * 2, tl, tm, l, min(r, tm)), self.query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)) if __name__ == \"__main__\": n, q = map(int, input().split()) arr = list(map(int, input().split())) segTree = SegmentTree(arr) for _ in range(q): query = list(map(int, input().split())) if query[0] == 1: p, x = query[1:] segTree.update(1, 0, n - 1, p - 1, x) else: l, r = query[1:] res = segTree.query(1, 0, n - 1, l - 1, r - 1) print(res.cnt2)\rimport java.util.*; class Node { long max1, cnt1, max2, cnt2; Node(long max1, long cnt1, long max2, long cnt2) { this.max1 = max1; this.cnt1 = cnt1; this.max2 = max2; this.cnt2 = cnt2; } Node() { this(-1, 0, -1, 0); } } class SegmentTree { private Node[] t; private long[] arr; private int n; SegmentTree(long[] arr) { this.arr = arr; n = arr.length; t = new Node[4 * n]; build(1, 0, n - 1); } private Node merge(Node left, Node right) { List\u003clong[]\u003e vals = new ArrayList\u003c\u003e(); vals.add(new long[]{left.max1, left.cnt1}); vals.add(new long[]{right.max1, right.cnt1}); vals.add(new long[]{left.max2, left.cnt2}); vals.add(new long[]{right.max2, right.cnt2}); vals.sort((a, b) -\u003e Long.compare(b[0], a[0])); Node parent = new Node(vals.get(0)[0], vals.get(0)[1]); for (int i = 1; i \u003c vals.size(); ++i) { long val = vals.get(i)[0]; long cnt = vals.get(i)[1]; if (val == parent.max1) { parent.cnt1 += cnt; } else if (parent.max2 \u003c val \u0026\u0026 val \u003c parent.max1) { parent.max2 = val; parent.cnt2 = cnt; } else if (val == parent.max2) { parent.cnt2 += cnt; } } return parent; } private void build(int v, int tl, int tr) { if (tl == tr) { t[v] = new Node(arr[tl], 1, -1, 0); } else { int tm = (tl + tr) / 2; build(v * 2, tl, tm); build(v * 2 + 1, tm + 1, tr); t[v] = merge(t[v * 2], t[v * 2 + 1]); } } private void update(int v, int tl, int tr, int pos, long new_val) { if (tl == tr) { t[v] = new Node(new_val, 1, -1, 0); } else { int tm = (tl + tr) / 2; if (pos \u003c= tm) update(v * 2, tl, tm, pos, new_val); else update(v * 2 + 1, tm + 1, tr, pos, new_val); t[v] = merge(t[v * 2], t[v * 2 + 1]); } } private Node query(int v, int tl, int tr, int l, int r) { if (l \u003e r) return new Node(); if (l == tl \u0026\u0026 r == tr) { return t[v]; } int tm = (tl + tr) / 2; return merge(query(v * 2, tl, tm, l, Math.min(r, tm)), query(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r)); } public void update(int pos, long new_val) { update(1, 0, n - 1, pos, new_val); } public Node query(int l, int r) { return query(1, 0, n - 1, l - 1, r - 1); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int q = scanner.nextInt(); long[] arr = new long[n]; for (int i = 0; i \u003c n; ++i) arr[i] = scanner.nextLong(); SegmentTree segTree = new SegmentTree(arr); for (int i = 0; i \u003c q; ++i) { int type = scanner.nextInt(); if (type == 1) { int p = scanner.nextInt(); long x = scanner.nextLong(); segTree.update(p - 1, x); } else { int l = scanner.nextInt(); int r = scanner.nextInt(); Node res = segTree.query(l, r); System.out.println(res.cnt2); } } } }\r#include \u003cbits/stdc++.h\u003e using namespace std; struct Node { long long max1, cnt1, max2, cnt2; Node(long long max1 = -1, long long cnt1 = 0, long long max2 = -1, long long cnt2 = 0) : max1(max1), cnt1(cnt1), max2(max2), cnt2(cnt2) {} }; class SegmentTree { private: vector\u003cNode\u003e t; vector\u003clong long\u003e arr; int n; Node merge(const Node\u0026 left, const Node\u0026 right) { vector\u003cpair\u003clong long, long long\u003e\u003e vals = { {left.max1, left.cnt1}, {right.max1, right.cnt1}, {left.max2, left.cnt2}, {right.max2, right.cnt2} }; sort(vals.rbegin(), vals.rend()); Node parent = Node(vals[0].first, vals[0].second); for (size_t i = 1; i \u003c vals.size(); ++i) { auto val = vals[i].first, cnt = vals[i].second; if (val == parent.max1) { parent.cnt1 += cnt; } else if (parent.max2 \u003c val \u0026\u0026 val \u003c parent.max1) { parent.max2 = val; parent.cnt2 = cnt; } else if (val == parent.max2) { parent.cnt2 += cnt; } } return parent; } void build(int v, int tl, int tr) { if (tl == tr) { t[v] = Node(arr[tl], 1); } else { int tm = (tl + tr) / 2; build(v*2, tl, tm); build(v*2+1, tm+1, tr); t[v] = merge(t[v*2], t[v*2+1]); } } void update(int v, int tl, int tr, int pos, long long new_val) { if (tl == tr) { t[v] = Node(new_val, 1); } else { int tm = (tl + tr) / 2; if (pos \u003c= tm) update(v*2, tl, tm, pos, new_val); else update(v*2+1, tm+1, tr, pos, new_val); t[v] = merge(t[v*2], t[v*2+1]); } } Node query(int v, int tl, int tr, int l, int r) { if (l \u003e r) return Node(); if (l == tl \u0026\u0026 r == tr) { return t[v]; } int tm = (tl + tr) / 2; return merge(query(v*2, tl, tm, l, min(r, tm)), query(v*2+1, tm+1, tr, max(l, tm+1), r)); } public: SegmentTree(vector\u003clong long\u003e\u0026 _arr) : arr(_arr) { n = arr.size(); t.resize(4 * n); build(1, 0, n-1); } void update(int pos, long long new_val) { update(1, 0, n-1, pos, new_val); } Node query(int l, int r) { return query(1, 0, n-1, l-1, r-1); } }; signed main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin \u003e\u003e n \u003e\u003e q; vector\u003clong long\u003e arr(n); for (int i = 0; i \u003c n; ++i) cin \u003e\u003e arr[i]; SegmentTree segTree(arr); for (int i = 0; i \u003c q; ++i) { int type; cin \u003e\u003e type; if (type == 1) { int p; long long x; cin \u003e\u003e p \u003e\u003e x; segTree.update(p-1, x); } else { int l, r; cin \u003e\u003e l \u003e\u003e r; Node res = segTree.query(l, r); cout \u003c\u003c res.cnt2 \u003c\u003c \"\\n\"; } } return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Range Second Maximum With Count",
    "uri": "/competitive-programming/templates/datastructures/segmenttree/rangesecondmaxcount/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Data Structures \u003e Fenwick Tree",
    "content": "\r​\rPython\rJava\rC++\rclass FenwickTree: def __init__(self, n): self.tree = [0] * (n + 1) def query(self, idx): sum_val = 0 while idx \u003e 0: sum_val += self.tree[idx] idx -= idx \u0026 -idx return sum_val def update(self, idx, delta): while idx \u003c len(self.tree): self.tree[idx] += delta idx += idx \u0026 -idx def lower_bound(self, val): pos = 0 bit_mask = 1 \u003c\u003c (len(self.tree) - 1) sum_val = 0 while bit_mask: if pos + bit_mask \u003c len(self.tree) and sum_val + self.tree[pos + bit_mask] \u003c val: sum_val += self.tree[pos + bit_mask] pos += bit_mask bit_mask \u003e\u003e= 1 return pos + 1 # Example Usage nums = [1, 3, 5, 7, 9, 11] ft = FenwickTree(len(nums)) for i in range(len(nums)): ft.update(i + 1, nums[i]) # Query the sum of elements from index 1 to index 4 sum_val = ft.query(4) - ft.query(1 - 1) # Find the lower bound of value 6 lower_bound_index = ft.lower_bound(6)\rclass FenwickTree { private int[] tree; public FenwickTree(int n) { tree = new int[n + 1]; } public int query(int idx) { int sum = 0; while (idx \u003e 0) { sum += tree[idx]; idx -= (idx \u0026 -idx); } return sum; } public void update(int idx, int delta) { while (idx \u003c tree.length) { tree[idx] += delta; idx += (idx \u0026 -idx); } } public int lowerBound(int val) { int pos = 0; int bitMask = Integer.highestOneBit(tree.length - 1) \u003c\u003c 1; int sum = 0; for (int i = bitMask; i \u003e 0; i \u003e\u003e= 1) { if (pos + i \u003c tree.length \u0026\u0026 sum + tree[pos + i] \u003c val) { sum += tree[pos + i]; pos += i; } } return pos + 1; } } // Example Usage public class Main { public static void main(String[] args) { int[] nums = {1, 3, 5, 7, 9, 11}; FenwickTree ft = new FenwickTree(nums.length); for (int i = 0; i \u003c nums.length; ++i) { ft.update(i + 1, nums[i]); } // Query the sum of elements from index 1 to index 4 int sum = ft.query(4) - ft.query(1 - 1); // Find the lower bound of value 6 int lowerBoundIndex = ft.lowerBound(6); } }\r#include \u003cvector\u003e #include \u003calgorithm\u003e using namespace std; class FenwickTree { private: vector\u003cint\u003e tree; public: FenwickTree(int n) { tree.assign(n + 1, 0); } int query(int idx) { int sum = 0; while (idx \u003e 0) { sum += tree[idx]; idx -= (idx \u0026 -idx); } return sum; } void update(int idx, int delta) { while (idx \u003c tree.size()) { tree[idx] += delta; idx += (idx \u0026 -idx); } } int lowerBound(int val) { int pos = 0; int bitMask = 1; int sum = 0; int len = tree.size(); while (bitMask \u003c len) bitMask \u003c\u003c= 1; for (int i = bitMask; i \u003e 0; i \u003e\u003e= 1) { if (pos + i \u003c len \u0026\u0026 sum + tree[pos + i] \u003c val) { sum += tree[pos + i]; pos += i; } } return pos + 1; } }; // Example Usage int main() { vector\u003cint\u003e nums = {1, 3, 5, 7, 9, 11}; FenwickTree ft(nums.size()); for (int i = 0; i \u003c nums.size(); ++i) { ft.update(i + 1, nums[i]); } // Query the sum of elements from index 1 to index 4 int sum = ft.query(4) - ft.query(1 - 1); // Find the lower bound of value 6 int lower_bound_index = ft.lowerBound(6); return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Range Sum",
    "uri": "/competitive-programming/templates/datastructures/fenwicktree/rangesum/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Data Structures \u003e Segment Tree",
    "content": "\r​\rPython\rJava\rC++\rclass Node: def __init__(self): self.sum = 0 self.lazy = 0 class SegmentTree: def __init__(self, nums): self.tree = [Node() for _ in range(4 * len(nums))] self.build_tree(nums, 0, 0, len(nums) - 1) def propagate(self, node, start, end): if self.tree[node].lazy != 0: self.tree[node].sum += (end - start + 1) * self.tree[node].lazy if start != end: self.tree[2 * node + 1].lazy += self.tree[node].lazy self.tree[2 * node + 2].lazy += self.tree[node].lazy self.tree[node].lazy = 0 def build_tree(self, nums, node, start, end): if start == end: self.tree[node].sum = nums[start] return mid = start + (end - start) // 2 self.build_tree(nums, 2 * node + 1, start, mid) self.build_tree(nums, 2 * node + 2, mid + 1, end) self.tree[node].sum = self.tree[2 * node + 1].sum + self.tree[2 * node + 2].sum def update_point(self, node, start, end, idx, diff): self.propagate(node, start, end) if start == end: self.tree[node].sum += diff return mid = start + (end - start) // 2 if idx \u003c= mid: self.update_point(2 * node + 1, start, mid, idx, diff) else: self.update_point(2 * node + 2, mid + 1, end, idx, diff) self.tree[node].sum = self.tree[2 * node + 1].sum + self.tree[2 * node + 2].sum def update_range(self, node, start, end, left, right, diff): self.propagate(node, start, end) if start \u003e right or end \u003c left: return if left \u003c= start and end \u003c= right: self.tree[node].sum += (end - start + 1) * diff if start != end: self.tree[2 * node + 1].lazy += diff self.tree[2 * node + 2].lazy += diff return mid = start + (end - start) // 2 self.update_range(2 * node + 1, start, mid, left, right, diff) self.update_range(2 * node + 2, mid + 1, end, left, right, diff) self.tree[node].sum = self.tree[2 * node + 1].sum + self.tree[2 * node + 2].sum def query_range(self, node, start, end, left, right): self.propagate(node, start, end) if start \u003e right or end \u003c left: return 0 if left \u003c= start and end \u003c= right: return self.tree[node].sum mid = start + (end - start) // 2 left_sum = self.query_range(2 * node + 1, start, mid, left, right) right_sum = self.query_range(2 * node + 2, mid + 1, end, left, right) return left_sum + right_sum def update(self, idx, val): diff = val - self.query(idx, idx) self.update_point(0, 0, len(self.tree) // 4 - 1, idx, diff) def update(self, left, right, val): self.update_range(0, 0, len(self.tree) // 4 - 1, left, right, val) def query(self, left, right): return self.query_range(0, 0, len(self.tree) // 4 - 1, left, right) # Example usage: nums = [1, 3, 2, 7, 9, 11] st = SegmentTree(nums) st.update(1, 3, 2) # Add 2 to elements in range [1, 3] print(st.query(1, 3)) # Output: 17 (sum of elements in range [1, 3] after update) print(st.query(0, 5)) # Output: 35 (sum of elements in range [0, 5] after update) st.update(1, 5) # Update element at index 1 to 5\rimport java.util.*; class Node { int sum; int lazy; Node() { sum = 0; lazy = 0; } } class SegmentTree { private Node[] tree; SegmentTree(int[] nums) { tree = new Node[4 * nums.length]; buildTree(nums, 0, 0, nums.length - 1); } private int merge(int a, int b) { return a + b; } private void propagate(int node, int start, int end) { if (tree[node].lazy != 0) { tree[node].sum += (end - start + 1) * tree[node].lazy; if (start != end) { tree[2 * node + 1].lazy += tree[node].lazy; tree[2 * node + 2].lazy += tree[node].lazy; } tree[node].lazy = 0; } } private void buildTree(int[] nums, int node, int start, int end) { tree[node] = new Node(); if (start == end) { tree[node].sum = nums[start]; return; } int mid = start + (end - start) / 2; buildTree(nums, 2 * node + 1, start, mid); buildTree(nums, 2 * node + 2, mid + 1, end); tree[node].sum = merge(tree[2 * node + 1].sum, tree[2 * node + 2].sum); } void updatePoint(int node, int start, int end, int idx, int diff) { propagate(node, start, end); if (start == end) { tree[node].sum += diff; return; } int mid = start + (end - start) / 2; if (idx \u003c= mid) updatePoint(2 * node + 1, start, mid, idx, diff); else updatePoint(2 * node + 2, mid + 1, end, idx, diff); tree[node].sum = tree[2 * node + 1].sum + tree[2 * node + 2].sum; } void update(int idx, int val) { int diff = val - query(idx, idx); updatePoint(0, 0, tree.length / 4 - 1, idx, diff); } void updateRange(int node, int start, int end, int left, int right, int diff) { propagate(node, start, end); if (start \u003e right || end \u003c left) { return; } if (left \u003c= start \u0026\u0026 end \u003c= right) { tree[node].sum += (end - start + 1) * diff; if (start != end) { tree[2 * node + 1].lazy += diff; tree[2 * node + 2].lazy += diff; } return; } int mid = start + (end - start) / 2; updateRange(2 * node + 1, start, mid, left, right, diff); updateRange(2 * node + 2, mid + 1, end, left, right, diff); tree[node].sum = merge(tree[2 * node + 1].sum, tree[2 * node + 2].sum); } int queryRange(int node, int start, int end, int left, int right) { propagate(node, start, end); if (start \u003e right || end \u003c left) { return 0; } if (left \u003c= start \u0026\u0026 end \u003c= right) { return tree[node].sum; } int mid = start + (end - start) / 2; int leftSum = queryRange(2 * node + 1, start, mid, left, right); int rightSum = queryRange(2 * node + 2, mid + 1, end, left, right); return leftSum + rightSum; } void update(int left, int right, int val) { updateRange(0, 0, tree.length / 4 - 1, left, right, val); } int query(int left, int right) { return queryRange(0, 0, tree.length / 4 - 1, left, right); } public static void main(String[] args) { int[] nums = {1, 3, 2, 7, 9, 11}; SegmentTree st = new SegmentTree(nums); st.update(1, 3, 2); // Add 2 to elements in range [1, 3] System.out.println(st.query(1, 3)); // Output: 17 (sum of elements in range [1, 3] after update) System.out.println(st.query(0, 5)); // Output: 35 (sum of elements in range [0, 5] after update) st.update(1, 5); // Update element at index 1 to 5 } }\r#include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; class Node { public: int sum; int lazy; Node() { sum = 0; lazy = 0; } }; class SegmentTree { private: vector\u003cNode\u003e tree; void propagate(int node, int start, int end) { if (tree[node].lazy != 0) { tree[node].sum += (end - start + 1) * tree[node].lazy; if (start != end) { tree[2 * node + 1].lazy += tree[node].lazy; tree[2 * node + 2].lazy += tree[node].lazy; } tree[node].lazy = 0; } } void updateRange(int node, int start, int end, int left, int right, int diff) { propagate(node, start, end); if (start \u003e right || end \u003c left) { return; } if (left \u003c= start \u0026\u0026 end \u003c= right) { tree[node].sum += (end - start + 1) * diff; if (start != end) { tree[2 * node + 1].lazy += diff; tree[2 * node + 2].lazy += diff; } return; } int mid = start + (end - start) / 2; updateRange(2 * node + 1, start, mid, left, right, diff); updateRange(2 * node + 2, mid + 1, end, left, right, diff); tree[node].sum = tree[2 * node + 1].sum + tree[2 * node + 2].sum; } int queryRange(int node, int start, int end, int left, int right) { propagate(node, start, end); if (start \u003e right || end \u003c left) { return 0; } if (left \u003c= start \u0026\u0026 end \u003c= right) { return tree[node].sum; } int mid = start + (end - start) / 2; int leftSum = queryRange(2 * node + 1, start, mid, left, right); int rightSum = queryRange(2 * node + 2, mid + 1, end, left, right); return leftSum + rightSum; } void updatePoint(int node, int start, int end, int idx, int diff) { propagate(node, start, end); if (start == end) { tree[node].sum += diff; return; } int mid = start + (end - start) / 2; if (idx \u003c= mid) updatePoint(2 * node + 1, start, mid, idx, diff); else updatePoint(2 * node + 2, mid + 1, end, idx, diff); tree[node].sum = tree[2 * node + 1].sum + tree[2 * node + 2].sum; } public: SegmentTree(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); tree.resize(4 * n); buildTree(nums, 0, 0, n - 1); } void buildTree(vector\u003cint\u003e\u0026 nums, int node, int start, int end) { if (start == end) { tree[node].sum = nums[start]; return; } int mid = start + (end - start) / 2; buildTree(nums, 2 * node + 1, start, mid); buildTree(nums, 2 * node + 2, mid + 1, end); tree[node].sum = tree[2 * node + 1].sum + tree[2 * node + 2].sum; } void update(int left, int right, int val) { updateRange(0, 0, tree.size() / 4 - 1, left, right, val); } void update(int idx, int val) { int diff = val - query(idx, idx); updatePoint(0, 0, tree.size() / 4 - 1, idx, diff); } int query(int left, int right) { return queryRange(0, 0, tree.size() / 4 - 1, left, right); } }; int main() { vector\u003cint\u003e nums = {1, 3, 2, 7, 9, 11}; SegmentTree st(nums); st.update(1, 3, 2); // Update elements in range [1, 3] by adding 2 cout \u003c\u003c st.query(1, 3) \u003c\u003c endl; // Output: 17 (sum of elements in range [1, 3] after update) cout \u003c\u003c st.query(0, 5) \u003c\u003c endl; // Output: 35 (sum of elements in range [0, 5] after update) st.update(2, 5); // Update element at index 2 to 5 cout \u003c\u003c st.query(0, 5) \u003c\u003c endl; // Output: 40 (sum of elements in range [0, 5] after update) return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Range Sum",
    "uri": "/competitive-programming/templates/datastructures/segmenttree/rangesum/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Data Structures",
    "content": " No Title Link 1 Range Sum Click to view 2 Range Second Maximum With Count Click to view ",
    "description": "",
    "tags": null,
    "title": "Segment Tree",
    "uri": "/competitive-programming/templates/datastructures/segmenttree/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms",
    "content": " No Title Link 1 KMP Click to view 2 Z-Function Click to view 3 Rabin-Karp Click to view ",
    "description": "",
    "tags": null,
    "title": "Strings",
    "uri": "/competitive-programming/templates/algorithms/strings/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming",
    "content": " No Title Link 1 Algorithms Click to view 2 Data Structures Click to view ",
    "description": "",
    "tags": null,
    "title": "Templates",
    "uri": "/competitive-programming/templates/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming",
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tricks",
    "uri": "/competitive-programming/tricks/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Data Structures",
    "content": "\r​\rPython\rJava\rC++\rclass TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True # Example usage: trie = Trie() words = [\"apple\", \"banana\", \"app\", \"orange\", \"orangejuice\"] for word in words: trie.insert(word) print(trie.search(\"apple\")) # True print(trie.search(\"app\")) # True print(trie.search(\"banana\")) # True print(trie.search(\"oran\")) # False print(trie.starts_with(\"oran\")) # True print(trie.search(\"grape\")) # False\rimport java.util.*; class TrieNode { Map\u003cCharacter, TrieNode\u003e children; boolean isEndOfWord; TrieNode() { children = new HashMap\u003c\u003e(); isEndOfWord = false; } } public class Trie { private TrieNode root; public Trie() { root = new TrieNode(); } public void insert(String word) { TrieNode current = root; for (char c : word.toCharArray()) { current.children.putIfAbsent(c, new TrieNode()); current = current.children.get(c); } current.isEndOfWord = true; } public boolean search(String word) { TrieNode current = root; for (char c : word.toCharArray()) { if (!current.children.containsKey(c)) { return false; } current = current.children.get(c); } return current.isEndOfWord; } public boolean startsWith(String prefix) { TrieNode current = root; for (char c : prefix.toCharArray()) { if (!current.children.containsKey(c)) { return false; } current = current.children.get(c); } return true; } public static void main(String[] args) { Trie trie = new Trie(); trie.insert(\"apple\"); System.out.println(trie.search(\"apple\")); // Output: true System.out.println(trie.search(\"app\")); // Output: false System.out.println(trie.startsWith(\"app\")); // Output: true trie.insert(\"app\"); System.out.println(trie.search(\"app\")); // Output: true } }\r#include \u003ciostream\u003e #include \u003cunordered_map\u003e #include \u003cstring\u003e using namespace std; class TrieNode { public: unordered_map\u003cchar, TrieNode*\u003e children; bool isEndOfWord; TrieNode() : isEndOfWord(false) {} }; class Trie { private: TrieNode* root; public: Trie() { root = new TrieNode(); } void insert(string word) { TrieNode* current = root; for (char c : word) { if (current-\u003echildren.find(c) == current-\u003echildren.end()) { current-\u003echildren[c] = new TrieNode(); } current = current-\u003echildren[c]; } current-\u003eisEndOfWord = true; } bool search(string word) { TrieNode* current = root; for (char c : word) { if (current-\u003echildren.find(c) == current-\u003echildren.end()) { return false; } current = current-\u003echildren[c]; } return current-\u003eisEndOfWord; } bool startsWith(string prefix) { TrieNode* current = root; for (char c : prefix) { if (current-\u003echildren.find(c) == current-\u003echildren.end()) { return false; } current = current-\u003echildren[c]; } return true; } }; int main() { Trie trie; trie.insert(\"apple\"); cout \u003c\u003c trie.search(\"apple\") \u003c\u003c endl; // Output: 1 (true) cout \u003c\u003c trie.search(\"app\") \u003c\u003c endl; // Output: 0 (false) cout \u003c\u003c trie.startsWith(\"app\") \u003c\u003c endl; // Output: 1 (true) trie.insert(\"app\"); cout \u003c\u003c trie.search(\"app\") \u003c\u003c endl; // Output: 1 (true) return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Trie",
    "uri": "/competitive-programming/templates/datastructures/trie/index.html"
  },
  {
    "breadcrumb": "Kode Kaavalan \u003e Competitive Programming \u003e Templates \u003e Algorithms \u003e Graphs",
    "content": "\r​\rPython\rJava\rC++\rclass UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [1 for _ in range(n)] self.rank[0] = 10 ** 5 + 1 def find(self, x: int) -\u003e int: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int) -\u003e None: parentX, parentY = self.parent[x], self.parent[y] if parentX == parentY: return if self.rank[parentX] \u003e self.rank[parentY]: self.parent[parentY] = parentX elif self.rank[parentX] \u003c self.rank[parentY]: self.parent[parentX] = parentY else: self.parent[parentY] = parentX self.rank[parentX] += 1 def is_connected(self, x: int, y: int) -\u003e bool: return self.find(x) == self.find(y) def reset(self, x: int) -\u003e None: self.parent[x] = x self.rank[x] = 1 # Create an instance of UnionFind for 10 elements uf = UnionFind(10) # Perform some union operations uf.union(1, 2) uf.union(3, 4) uf.union(1, 4) # This will connect 1, 2, 3, and 4 in the same set # Check if two elements are connected print(uf.is_connected(1, 3)) # Output: True, as 1 and 3 are now connected through 2 and 4 print(uf.is_connected(1, 5)) # Output: False, as 5 is not connected to 1, 2, 3, or 4 # Reset an element uf.reset(2) print(uf.is_connected(1, 2)) # Output: False, as 2 has been reset and is no longer connected to 1 # Additional demonstration print(uf.is_connected(3, 4)) # Output: True, because 3 and 4 are still connected\rpublic class UnionFind { private int[] parent; private int[] rank; public UnionFind(int n) { parent = new int[n]; rank = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; // Each element is its own parent initially. rank[i] = 1; // Initial rank of 1 for all elements. } } public int find(int x) { if (parent[x] != x) { // Path compression by halving. parent[x] = find(parent[x]); } return parent[x]; } public void union(int x, int y) { int parentX = find(x); int parentY = find(y); if (parentX != parentY) { if (rank[parentX] \u003e rank[parentY]) { parent[parentY] = parentX; } else if (rank[parentX] \u003c rank[parentY]) { parent[parentX] = parentY; } else { parent[parentY] = parentX; rank[parentX]++; } } } public boolean isConnected(int x, int y) { return find(x) == find(y); } public void reset(int x) { parent[x] = x; rank[x] = 1; } } public class Main { public static void main(String[] args) { // Create an instance of UnionFind for 10 elements UnionFind uf = new UnionFind(10); // Perform some union operations uf.union(1, 2); uf.union(3, 4); uf.union(1, 4); // This will connect 1, 2, 3, and 4 in the same set // Check if two elements are connected System.out.println(uf.isConnected(1, 3)); // Output: true, as 1 and 3 are now connected through 2 and 4 System.out.println(uf.isConnected(1, 5)); // Output: false, as 5 is not connected to 1, 2, 3, or 4 // Reset an element uf.reset(2); System.out.println(uf.isConnected(1, 2)); // Output: false, as 2 has been reset and is no longer connected to 1 // Additional demonstration System.out.println(uf.isConnected(3, 4)); // Output: true, because 3 and 4 are still connected } }\rclass UnionFind { private: vector\u003cint\u003e parent; vector\u003cint\u003e rank; public: UnionFind(int n) : parent(n), rank(n, 1) { // Initialize parent so each element is its own parent. for (int i = 0; i \u003c n; ++i) { parent[i] = i; } } int find(int x) { if (parent[x] != x) { // Path compression parent[x] = find(parent[x]); } return parent[x]; } void unite(int x, int y) { int parentX = find(x); int parentY = find(y); if (parentX != parentY) { if (rank[parentX] \u003e rank[parentY]) { parent[parentY] = parentX; } else if (rank[parentX] \u003c rank[parentY]) { parent[parentX] = parentY; } else { parent[parentY] = parentX; rank[parentX] += 1; } } } bool isConnected(int x, int y) { return find(x) == find(y); } void reset(int x) { parent[x] = x; rank[x] = 1; } }; int main() { // Create an instance of UnionFind for 10 elements UnionFind uf(10); // Perform some union operations uf.unite(1, 2); uf.unite(3, 4); uf.unite(1, 4); // This will connect 1, 2, 3, and 4 in the same set // Check if two elements are connected cout \u003c\u003c uf.isConnected(1, 3) \u003c\u003c endl; // Output: 1 (True), as 1 and 3 are now connected through 2 and 4 cout \u003c\u003c uf.isConnected(1, 5) \u003c\u003c endl; // Output: 0 (False), as 5 is not connected to 1, 2, 3, or 4 // Reset an element uf.reset(2); cout \u003c\u003c uf.isConnected(1, 2) \u003c\u003c endl; // Output: 0 (False), as 2 has been reset and is no longer connected to 1 // Additional demonstration cout \u003c\u003c uf.isConnected(3, 4) \u003c\u003c endl; // Output: 1 (True), because 3 and 4 are still connected return 0; }\r",
    "description": "",
    "tags": null,
    "title": "Union Find",
    "uri": "/competitive-programming/templates/algorithms/graphs/unionfind/index.html"
  }
]
